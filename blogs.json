{"status":"ok","feed":{"url":"https://medium.com/feed/@shaf","title":"Stories by Dmytro Shaforostov on Medium","link":"https://medium.com/@shaf?source=rss-9892ec3de761------2","author":"","description":"Stories by Dmytro Shaforostov on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/2*hHNZt8suS5tvhnDqARlsew.jpeg"},"items":[{"title":"Electronic-Stories: emit more powerful stories","pubDate":"2018-12-03 17:11:36","link":"https://medium.com/@shaf/electronic-stories-emit-more-powerful-stories-39ee1cc3fd2a?source=rss-9892ec3de761------2","guid":"https://medium.com/p/39ee1cc3fd2a","author":"Dmytro Shaforostov","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8Ew3TvyX_AEEDgh_eE5SvA.png\"></figure><p>Divide and conquer\u200a\u2014\u200ais the main approach to programming and basically to all complex tasks. Components abstraction perfectly implement it. Same as an idea of developing them in an isolated environment like react-styleguidist and storybook. Mock, or use real data, you can remove all unnecessary stuff from a scene and concentrate on creating a required component.</p>\n<p>Although storybook almost become a standard for developing web apps it is not really clear how to develop components for electron-based applications.<br>It may work if you use just standard web functionality, but it not designed for work with Electron desktop-app features. Mainly because it using iframe, as described in <a href=\"https://github.com/storybooks/storybook/issues/1435\">storybook issue</a>.</p>\n<p><strong>Electronic-Stories is an attempt of solving this issue</strong>. Basically, it is another electron app that provides electron environment while you developing your application.</p>\n<p>After been installed and added to your npm scripts in \u201cpackage.json\u201d as \u201celectronic-stories\u201d: \u201celectronic-stories\u201d. Then run \u201cnpm run electronic-stories\u201d command, which will open Electron instance and show you stories in separate process using \u201cwebview\u201d.<br>You will require to serve a script that loads all your stories on 9001 port HTML with, for\u00a0example:</p>\n<pre>// index.js<br>(r =&gt; r.keys().forEach(r))(<br>  require.context(\u2018./story\u2019, true, /\\.tale\\.jsx$/),<br>);</pre>\n<pre>// some.story.js<br>/* global storiesOf */<br>import React from \u2018react\u2019;</pre>\n<pre>storiesOf(\u2018Basic\u2019)<br> .add(<br>   \u2018First\u2019,<br>   () =&gt; (<br>     &lt;button type=\u201dbutton\u201d&gt;First&lt;/button&gt;<br>   ),<br> ).add(<br>   \u2018Second\u2019,<br>   () =&gt; (<br>     &lt;button type=\u201dbutton\u201d&gt;Second&lt;/button&gt;<br>   ),<br> );</pre>\n<p>Notice that for proper work HTML file served on port must have \u201croot\u201d element and have \u201cindex.js\u201d script.</p>\n<pre>// index.tpl.js<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br> &lt;head&gt;<br> &lt;meta charset=\u201dutf-8\"&gt;<br> &lt;title&gt;Stories&lt;/title&gt;<br> &lt;/head&gt;<br> &lt;body&gt;<br> &lt;div id=\u201droot\u201d&gt;&lt;/div&gt;<br> &lt;script type=\u201dtext/javascript\u201d src=\u201d/bundle.js\u201d&gt;&lt;/script&gt;<br> &lt;/body&gt;<br>&lt;/html&gt;</pre>\n<p>For example you can use webpack for serving\u00a0stories:</p>\n<pre>// webpack.config.js<br>const path = require(\u2018path\u2019);</pre>\n<pre>module.exports = () =&gt; ({<br> target: \u2018electron-renderer\u2019,<br> mode: \u2018development\u2019,<br> devtool: \u2018eval-source-map\u2019,<br> entry: {<br>   app: path.join(__dirname, \u2018./index.js\u2019),<br> },<br> output: {<br>   path: path.resolve(__dirname, \u2018dist\u2019),<br>   publicPath: \u2018/\u2019,<br>   filename: \u2018bundle.js\u2019,<br> },<br> devServer: {<br>   contentBase: path.resolve(__dirname, \u2018dist\u2019),<br>   port: 9001,<br>   compress: true,<br>   headers: {<br>     \u2018Access-Control-Allow-Origin\u2019: \u2018*\u2019,<br>   },<br> },<br>});</pre>\n<p>Electronic-Stories will get code, implant \u201cstoriesOf\u201d function to global scope and render stories list for switching between stories and will render components from stories\u00a0itself.</p>\n<p>Main feature that made this possible is an execution of preload script for webview.<br>Just before your modules with stories is start execution preload place API for them into global scope.<br>Calling storiesOf you create a new collection of stories that will add to list that will be sent to render process.<br>Preload script also will listen to events for switching between stories and will call react-dom\u2019s render for showing them.<br>For now, Electronic-Stories works only for react components.</p>\n<p>Another great thing is that you can run chromium devtools specifically for webview to inspect and receive your \u201cNever happens\u201d messages into\u00a0console.</p>\n<p>Electronic-Stories provides great flexibility for developing components. Currently provides API with minimum features, so PR\u2019s are welcome at <a href=\"https://github.com/LambdaBird/electronic-stories\">GetHub\u00a0Repo</a>!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=39ee1cc3fd2a\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8Ew3TvyX_AEEDgh_eE5SvA.png\"></figure><p>Divide and conquer\u200a\u2014\u200ais the main approach to programming and basically to all complex tasks. Components abstraction perfectly implement it. Same as an idea of developing them in an isolated environment like react-styleguidist and storybook. Mock, or use real data, you can remove all unnecessary stuff from a scene and concentrate on creating a required component.</p>\n<p>Although storybook almost become a standard for developing web apps it is not really clear how to develop components for electron-based applications.<br>It may work if you use just standard web functionality, but it not designed for work with Electron desktop-app features. Mainly because it using iframe, as described in <a href=\"https://github.com/storybooks/storybook/issues/1435\">storybook issue</a>.</p>\n<p><strong>Electronic-Stories is an attempt of solving this issue</strong>. Basically, it is another electron app that provides electron environment while you developing your application.</p>\n<p>After been installed and added to your npm scripts in \u201cpackage.json\u201d as \u201celectronic-stories\u201d: \u201celectronic-stories\u201d. Then run \u201cnpm run electronic-stories\u201d command, which will open Electron instance and show you stories in separate process using \u201cwebview\u201d.<br>You will require to serve a script that loads all your stories on 9001 port HTML with, for\u00a0example:</p>\n<pre>// index.js<br>(r =&gt; r.keys().forEach(r))(<br>  require.context(\u2018./story\u2019, true, /\\.tale\\.jsx$/),<br>);</pre>\n<pre>// some.story.js<br>/* global storiesOf */<br>import React from \u2018react\u2019;</pre>\n<pre>storiesOf(\u2018Basic\u2019)<br> .add(<br>   \u2018First\u2019,<br>   () =&gt; (<br>     &lt;button type=\u201dbutton\u201d&gt;First&lt;/button&gt;<br>   ),<br> ).add(<br>   \u2018Second\u2019,<br>   () =&gt; (<br>     &lt;button type=\u201dbutton\u201d&gt;Second&lt;/button&gt;<br>   ),<br> );</pre>\n<p>Notice that for proper work HTML file served on port must have \u201croot\u201d element and have \u201cindex.js\u201d script.</p>\n<pre>// index.tpl.js<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br> &lt;head&gt;<br> &lt;meta charset=\u201dutf-8\"&gt;<br> &lt;title&gt;Stories&lt;/title&gt;<br> &lt;/head&gt;<br> &lt;body&gt;<br> &lt;div id=\u201droot\u201d&gt;&lt;/div&gt;<br> &lt;script type=\u201dtext/javascript\u201d src=\u201d/bundle.js\u201d&gt;&lt;/script&gt;<br> &lt;/body&gt;<br>&lt;/html&gt;</pre>\n<p>For example you can use webpack for serving\u00a0stories:</p>\n<pre>// webpack.config.js<br>const path = require(\u2018path\u2019);</pre>\n<pre>module.exports = () =&gt; ({<br> target: \u2018electron-renderer\u2019,<br> mode: \u2018development\u2019,<br> devtool: \u2018eval-source-map\u2019,<br> entry: {<br>   app: path.join(__dirname, \u2018./index.js\u2019),<br> },<br> output: {<br>   path: path.resolve(__dirname, \u2018dist\u2019),<br>   publicPath: \u2018/\u2019,<br>   filename: \u2018bundle.js\u2019,<br> },<br> devServer: {<br>   contentBase: path.resolve(__dirname, \u2018dist\u2019),<br>   port: 9001,<br>   compress: true,<br>   headers: {<br>     \u2018Access-Control-Allow-Origin\u2019: \u2018*\u2019,<br>   },<br> },<br>});</pre>\n<p>Electronic-Stories will get code, implant \u201cstoriesOf\u201d function to global scope and render stories list for switching between stories and will render components from stories\u00a0itself.</p>\n<p>Main feature that made this possible is an execution of preload script for webview.<br>Just before your modules with stories is start execution preload place API for them into global scope.<br>Calling storiesOf you create a new collection of stories that will add to list that will be sent to render process.<br>Preload script also will listen to events for switching between stories and will call react-dom\u2019s render for showing them.<br>For now, Electronic-Stories works only for react components.</p>\n<p>Another great thing is that you can run chromium devtools specifically for webview to inspect and receive your \u201cNever happens\u201d messages into\u00a0console.</p>\n<p>Electronic-Stories provides great flexibility for developing components. Currently provides API with minimum features, so PR\u2019s are welcome at <a href=\"https://github.com/LambdaBird/electronic-stories\">GetHub\u00a0Repo</a>!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=39ee1cc3fd2a\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["electron","javascript","react"]}]}